{"hash":"b539c812d5d4ef62e983baebfbee63b2ffa846b5","data":{"post":{"title":"Android NDK, Descubriendo por qué la app Android de Instagram está escrita en C/C++","date":"January 4, 2021","content":"<h1 id=\"android-ndk-descubriendo-por-qué-la-app-android-de-instagram-está-escrita-en-cc\"><a href=\"#android-ndk-descubriendo-por-qu%C3%A9-la-app-android-de-instagram-est%C3%A1-escrita-en-cc\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Android NDK: Descubriendo por qué la app Android de Instagram está escrita en C/C++</h1>\n<p>¿Qué cara 🤪 pondrías si te dijera que algunas de las aplicaciones móviles que más utilizas en el día a día tienen parte\nde su código escrito en C o C++? Tal vez pensarías que es la típica pregunta con trampa y que tal vez utilizan alguna\nlibrería del sistema que está escrita en dichos lenguajes de programación. Pero este no es el caso de aplicaciones como\nWhatsapp, Skype, Instagram o Facebook donde parte del código de sus aplicaciones está escrito en estos lenguajes\nutilizando posteriormente el conjunto de herramientas del NDK de Android para hacer llamadas a las mismas. Muestra de\nesto es, por ejemplo, la siguiente oferta de trabajo publicada por Facebook donde buscan un/una Ingenier@ expert@ en el\nNDK de Android.</p>\n<p><img src=\"images/AndroidNDK/JobOffer.png\" alt=\"Oferta de trabajo para Android NDK de Facebook\"></p>\n<h2 id=\"¿qué-es-y-cómo-funciona-el-ndk-de-android-\"><a href=\"#%C2%BFqu%C3%A9-es-y-c%C3%B3mo-funciona-el-ndk-de-android-\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>¿Qué es y cómo funciona el NDK de Android? 📱</h2>\n<p>El NDK de Android (Native Development Kit) permite que l@s desarrollador@s podamos reutilizar código desarrollado en\nC/C++ pudiendo ejecutarlo en nuestras aplicaciones a través del uso de JNI (Java Native Interface). JNI es conjunto de\nherramientas que nos permite que cualquier programa escrito en Java, y por tanto, que funciona en la máquina virtual de\nJava, pueda ejecutar código escrito en otros lenguajes como C, C++ o incluso ensamblador.</p>\n<p>El NDK de Android nos permite a su vez manejar como se compilan nuestro código nativo utilizando NDK-build o CMake. El\nfuncionamiento general del NDK en nuestra aplicación Android sigue el flujo siguiente:</p>\n<p><img src=\"images/AndroidNDK/NDK_Android.png\" alt=\"Flujo de aplicación Android con código nativo C/C++\"></p>\n<p>Tenemos nuestro código Android donde en primer lugar debemos cargar la librería nativa que vamos a utilizar y la\ncabecera de los métodos nativos de la misma que utilizaremos. Mientras que por otro lado en nuestro código C/C++ debemos\ntener la implementación de esas funciones definidas en Java/Kotlin. Posteriormente, entraremos más en detalle en estos\naspectos con nuestro ejemplo práctico.</p>\n<p>Por otro lado, hay que tener en cuenta que nuestro código nativo no va a ejecutarse en una máquina virtual de Java y\nque, por tanto, debe estar compilado para que pueda ser ejecutado en las diferentes arquitecturas de procesadores\ndisponibles en Android si queremos que desde cualquier dispositivo se pueda ejecutar nuestra App. Además, las librerías\nque utilicemos, deben también compilarse para ser ejecutadas en las diferentes arquitecturas que soporte nuestra app. La\ncombinación entre la arquitecturas de CPU y los conjuntos de instrucciones que las mismas pueden ejecutar componen cada\nuna de las plataformas para las que debemos compilar nuestra aplicación. A día de hoy, estas son las combinaciones,\nllamadas ABI (interfaz binaria de aplicación), disponibles en Android:</p>\n<p><img src=\"images/AndroidNDK/ABIs.png\" alt=\"Conjunto de ABIS de Android\"></p>\n<p>Finalmente, hay que tener en cuenta que el uso del NDK puede ser útil en cierto tipo de aplicaciones, mientras que en\notras no sería necesario utilizarlo debido al aumento de la complejidad del proyecto sin obtener grandes beneficios por\nello.</p>\n<h2 id=\"¿cuándo-debería-utilizar-el-ndk-de-android\"><a href=\"#%C2%BFcu%C3%A1ndo-deber%C3%ADa-utilizar-el-ndk-de-android\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>¿Cuándo debería utilizar el NDK de Android?🤔</h2>\n<p>Desde mi punto de vista, hay dos situaciones principales donde me decantaría por utilizar código nativo en mi aplicación\nAndroid.</p>\n<p>Sin lugar a dudas el primer factor que me haría decantarme a utilizar el NDK de Android no es otro que la mejora de\nrendimiento de mi aplicación. En mi caso concreto, lo he utilizado comúnmente para ejecutar funciones criptográficas en\nmis aplicaciones, donde el uso de ciertas librerías para trabajar con funciones matemáticas escritas en C proporciona\nmayor rendimiento y facilidad para ejecutar las mismas. En este tipo de aplicaciones, el cifrado/descifrado de grandes\ncantidades de datos podría hacer inusable nuestra aplicación, por lo que el uso del NDK proporciona ese rendimiento\nextra necesario debido a que dichas operaciones son ejecutadas directamente en la CPU sin pasar por la JVM. Otro tipo de\naplicaciones donde el rendimiento es especialmente importante, son las relacionadas con la codificación de datos\nmultimedia como audio y video o los videojuegos donde el uso del NDK está totalmente recomendado.</p>\n<p>El segundo factor que me haría decantarme por el uso del NDK de Android sería el disponer de una amplia base de código\nescrita en este lenguaje, lo suficientemente estable, testeada y probada de manera que requiera de pocos cambios durante\nsu vida útil o cuyo equipo de desarrollo pueda mantener la misma.</p>\n<h2 id=\"ejemplo-de-aplicación-utilizando-el-ndk-de-android-\"><a href=\"#ejemplo-de-aplicaci%C3%B3n-utilizando-el-ndk-de-android-\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Ejemplo de aplicación utilizando el NDK de Android 👀</h2>\n<p>El primer paso consiste en crearnos un nuevo proyecto en Android Studio basado en el NDK.</p>\n<p><img src=\"images/AndroidNDK/AndroidStudio.png\" alt=\"Template de proyecto de Android Studio\"></p>\n<p>Una vez que hayamos creado nuestro proyecto, dispondremos de nuestra aplicación Hello World utilizando el NDK. Podemos\nobservar como en la estructura de nuestro proyecto tenemos un directorio <code>Java</code>y otro directorio <code>cpp</code> donde tendremos\nel código Java y el código nativo respectivamente.</p>\n<p><img src=\"images/AndroidNDK/ProjectStructure.png\" alt=\"Estructura de proyecto con NDK de Android\"></p>\n<p>En el ejemplo que vamos a ver a continuación vamos a desarrollar una aplicación que cifra y descifra mensajes de texto.</p>\n<p>Aquí podemos ver una captura de la interfaz de usuario de la aplicación:</p>\n<p><img src=\"images/AndroidNDK/Screenshot.png\" alt=\"Imagen de la aplicación de ejemplo desarrollada\"></p>\n<p>Como podemos ver disponemos de dos botones <code>cifrar</code>y <code>descifrar</code>, que son los encargados de invocar a nuestras funciones\nresponsables de dicho cometido. Dichas funciones, internamente harán uso de la librerías propias de <code>openssl</code> escritas\nen C para hacer ejecutar diferentes funciones y algoritmos criptográficos. Un aspecto importante a la hora de utilizar\nel NDK de Android es que tendremos que realizar una envoltura a las diferentes funciones que utilicemos de nuestro\ncódigo C y que queramos invocar desde nuestro código Java/Kotlin. Es se debe a que dichas funciones deben utilizar el\nJNI para recibir como entrada los tipos de datos necesarios, convertirlos a tipos de datos válidos en C y hacer la\noperación inversa en el momento de devolver algún resultado, convertir los tipos de datos de C a tipos de datos válidos\nen Java.</p>\n<p>El primer paso para configurar nuestra aplicación consiste en importar nuestra librería así como la librería <code>openssl</code> a\nnuestro proyecto. Para ello además de tener los ficheros necesarios en nuestro proyecto, debemos enlazarlos dentro del\nfichero <code>CMakeLists.txt</code>.</p>\n<p><img src=\"images/AndroidNDK/Libraries.png\" alt=\"Esctructura de las librerías a incluir en la app de ejemplo\"></p>\n<p>Como podemos observar en la imagen, dentro del directorio <code>cpp</code> tenemos la librería <code>openssl</code> previamente compilada para\ncada una de las ABIs que vamos a soportar en el proyecto (que podrían o no ser todas las disponibles, o solo un\nsubconjunto de las mismas) así como el directorio <code>include</code> donde tenemos los ficheros de cabecera con las diferentes\nfunciones de la librería <code>openssl</code> que vamos a utilizar.</p>\n<p>Por otro lado, tenemos nuestra librería, <code>crypto.c</code> y su correspondiente fichero de cabeceras <code>crypto.h</code> y el\nfichero <code>main.c</code> punto de entrada a nuestro código nativo.</p>\n<p>A continuación, podemos observar el fichero <code>CMakeLists.txt</code> con cada una de las opciones comentadas para entenderlas\nmejor.</p>\n<pre class=\"shiki\" style=\"background-color: #292D3E\"><code><span style=\"color: #676E95\"># versión mínima de CMake necesaria para compilar la librería</span>\n<span style=\"color: #FFFFFF\">cmake_minimum_required(VERSION 3.10.2)</span>\n\n<span style=\"color: #676E95\"># declaración y nombre del proyecto</span>\n<span style=\"color: #FFFFFF\">project(\"samplendkapp\")</span>\n\n<span style=\"color: #676E95\">#inclusión de los ficheros de cabecera de las librerías a utilizar (openssl)</span>\n<span style=\"color: #FFFFFF\">include_directories(${CMAKE_CURRENT_SOURCE_DIR}/openssl/include) </span>\n\n<span style=\"color: #676E95\"># Añadimos nuevas librerías, libcrypto y libssl que son los dos componentes de openssl</span>\n<span style=\"color: #FFFFFF\">add_library(libcrypto STATIC IMPORTED) </span>\n<span style=\"color: #FFFFFF\">add_library(libssl STATIC IMPORTED)</span>\n\n<span style=\"color: #676E95\"># Linkamos las librerias con los ejecutables previamente compilados utilizando la variable ${ANDROID_ABI} para diferenciar por tipo de ABI</span>\n<span style=\"color: #FFFFFF\">set_target_properties(libcrypto PROPERTIES IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/openssl/lib/${ANDROID_ABI}/lib/libcrypto.a)</span>\n<span style=\"color: #FFFFFF\">set_target_properties(libssl PROPERTIES IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/openssl/lib/${ANDROID_ABI}/lib/libssl.a)</span>\n\n<span style=\"color: #FFFFFF\">add_library( </span><span style=\"color: #676E95\"># seteamos el nombre de la nueva librería que vamos a crear para se consumidad de Java/Kotlin.</span>\n<span style=\"color: #FFFFFF\">             native-lib</span>\n<span style=\"color: #89DDFF\">             </span><span style=\"color: #676E95\"># La seteamos como compartida.</span>\n<span style=\"color: #FFFFFF\">             SHARED</span>\n<span style=\"color: #89DDFF\">             </span><span style=\"color: #676E95\"># Seteamos la ruta relativa a los ficheros fuente de nuestra librería</span>\n<span style=\"color: #FFFFFF\">             crypto.c</span>\n<span style=\"color: #FFFFFF\">             main.c )</span>\n\n<span style=\"color: #676E95\"># Busca una biblioteca predefinida especificada y almacena la ruta como variable. </span>\n<span style=\"color: #676E95\"># Debido a que CMake incluye bibliotecas del sistema en la ruta de búsqueda</span>\n<span style=\"color: #676E95\"># predeterminada, solo necesita especificar el nombre de la biblioteca pública del NDK</span>\n<span style=\"color: #676E95\"># que se desea agregar. CMake verifica que la biblioteca exista antes para</span>\n<span style=\"color: #676E95\"># completar su construcción.</span>\n\n<span style=\"color: #FFFFFF\">find_library( </span><span style=\"color: #676E95\"># nombre de la librería que utilizaremos.</span>\n<span style=\"color: #FFFFFF\">              log-lib</span>\n\n<span style=\"color: #89DDFF\">              </span><span style=\"color: #676E95\"># nombre de la librería del sistema que CMake debe localizar</span>\n<span style=\"color: #FFFFFF\">              log )</span>\n\n<span style=\"color: #676E95\"># Especifica las bibliotecas que CMake debe vincular a su librería de destino.</span>\n<span style=\"color: #676E95\"># Se pueden vincular varias librería , como las librería definidas en este</span>\n<span style=\"color: #676E95\"># script, bibliotecas de terceros precompiladas o bibliotecas del sistema.</span>\n\n<span style=\"color: #FFFFFF\">target_link_libraries( </span><span style=\"color: #676E95\"># librería de destino.</span>\n<span style=\"color: #FFFFFF\">                       native-lib</span>\n\n<span style=\"color: #89DDFF\">                       </span><span style=\"color: #676E95\"># Librerías que vamos a linkar a native-lib</span>\n<span style=\"color: #FFFFFF\">                        libcrypto</span>\n<span style=\"color: #FFFFFF\">                        libssl</span>\n<span style=\"color: #FFFFFF\">                       ${log-lib} )</span></code></pre>\n<p>El siguiente paso consiste en cargar nuestra librería nativa en nuestro código, para ello bastaría con un companion\nobject en la activity desde la cual lo vamos a llamar y crear las cabeceras de las funciones de nuestro código C que\nllamaremos desde aquí. La palabra reservada <code>external</code> hace referencia a que la función a la que vamos a llamar está\nescrita en un lenguaje diferente de Java/kotlin y en Java se declara con la palabra reservada <code>native</code>.</p>\n<code class=\"shiki\" style=\"background: #2e3440; color: #d8dee9\">private external fun encryptFromJNI(message: String): ByteArray\nprivate external fun decryptFromJNI(message: ByteArray): String\n\ncompanion object {\n        init {\n            System.loadLibrary(&quot;native-lib&quot;)\n        }\n    }</code>\n<p>Finalmente, creamos en C nuestras funciones que envuelve a los métodos que vamos a llamar de nuestra librería en código\nnativo (<a href=\"https://github.com/IvanSantosGonz/CryptAndDecriptAndroidNDK/blob/master/app/src/main/cpp/crypto.c\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">crypto.c</a>),\ny que recibe y devuelve objetos con tipado del JNI, que son fácilmente identificables debido a que todos los tipos\nempiezan por J, <code>jstring , jint, jchar, etc</code>. Otro aspecto a tener en cuenta, es que para que este método haga\nreferencia a la cabecera que declaramos desde Java/Kotlin, el nombre del mismo debe coincidir con la ruta completa del\nfichero donde la cabecera es invocada, separando cada subdirectorio con guion bajo.</p>\n<p>Finalmente, podemos observar también como se usa la palabra reservada <code>JNIEXPORT</code> seguida del tipo de dato que queremos\ndevolver, así como seguido de la palabra reservada <code>JNICALL</code> como anotación a cada método.</p>\n<p>El código completo de este ejemplo está disponible en el siguiente repositorio de Github:</p>\n<p><a href=\"https://github.com/IvanSantosGonz/CryptAndDecriptAndroidNDK\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/IvanSantosGonz/CryptAndDecriptAndroidNDK</a></p>\n<code class=\"shiki\" style=\"background: #2e3440; color: #d8dee9\">JNIEXPORT jbyteArray JNICALL\nJava_com_samplendkapp_MainActivity_encryptFromJNI(JNIEnv *env, jobject this, jstring message) {\n\n    int ciphertext_len;\n    unsigned char ciphertext[128];\n\n    unsigned char *plaintext = (*env)-&gt;GetStringUTFChars(env, message, 0);\n\n    ciphertext_len = encrypt(plaintext, strlen((char *) plaintext), key, iv,\n                             ciphertext);\n    BIO_dump_fp(stdout, (const char *) ciphertext, ciphertext_len);\n\n    jbyteArray array = (*env)-&gt;NewByteArray(env, ciphertext_len);\n    (*env)-&gt;SetByteArrayRegion(env, array, 0, ciphertext_len, (jbyte *) (ciphertext));\n    return array;\n}\n\nJNIEXPORT jstring JNICALL\nJava_com_samplendkapp_MainActivity_decryptFromJNI(JNIEnv *env, jobject this, jbyteArray message) {\n\n    int decryptedtext_len;\n\n    unsigned char decryptedtext[128];\n\n    int len = (*env)-&gt;GetArrayLength (env, message);\n    unsigned char encryptedText[len];\n    (*env)-&gt;GetByteArrayRegion (env, message, 0, len, (jbyte*) (encryptedText));\n\n    decryptedtext_len = decrypt(encryptedText, len, key, iv,\n                                decryptedtext);\n\n    decryptedtext[decryptedtext_len] = &#039;\\0&#039;;\n\n    return (*env)-&gt;NewStringUTF(env, decryptedtext);\n}</code>\n<h2 id=\"huevo-de-pascua-🥚\"><a href=\"#huevo-de-pascua-%F0%9F%A5%9A\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Huevo de Pascua 🥚🐰</h2>\n<p>Para no quedarnos con el click bait del título, hay que tener en cuenta que ciertas aplicaciones como son el caso de\nInstagram, tienen versiones diferentes de su aplicación en otras plataformas como Android, IOS o Web. En el caso\nconcreto de Instagram, se utilizan diferentes librerías escritas en C para la codificación de video, así como los\nfiltros de imágenes y otras partes de su aplicación son creados utilizando código nativo C/C++ por dos razones\nprincipales, tener la máxima eficiencia al aplicar los mismos, y a su vez poder reutilizar el código en todas las\nplataformas necesarias. En el caso de Instagram, al ser una aplicación privada no podemos tener la certeza de esto, pero\nsí que sabemos que es una práctica más común de lo que parece. Para ejemplo de ello, el código de una app que si podemos\nobservar es el de Telegram al ser de dominio\npúblico, (<a href=\"https://github.com/TelegramOrg/Telegram-Android/tree/master/TMessagesProj/jni\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">repositorio de Telegram</a>)\ndonde podemos observar la gran cantidad de librerías basadas en código nativo que utiliza.</p>\n<p><img src=\"images/AndroidNDK/Telegram.png\" alt=\"Repositorio de Telegram con código nativo utilizado\"></p>\n<h2 id=\"referencias-\"><a href=\"#referencias-\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Referencias 📚</h2>\n<ul>\n<li>Repositorio del\nejemplo: <a href=\"https://github.com/IvanSantosGonz/CryptAndDecriptAndroidNDK\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/IvanSantosGonz/CryptAndDecriptAndroidNDK</a></li>\n<li>Android developers NDK: <a href=\"https://developer.android.com/ndk\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://developer.android.com/ndk</a></li>\n<li>Android developers\nJNI: <a href=\"https://developer.android.com/training/articles/perf-jni?hl=es-419\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://developer.android.com/training/articles/perf-jni?hl=es-419</a></li>\n</ul>\n","tags":[{"title":"Android","path":"/tag/Android/"},{"title":"NDK","path":"/tag/NDK/"},{"title":"C","path":"/tag/C/"},{"title":"C++","path":"/tag/C%2B%2B/"}]}},"context":{}}